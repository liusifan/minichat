/* logic_tool_impl.cpp

 Generated by phxrpc_pb2tool from logic.proto

*/

#include "logic_tool_impl.h"
#include "logic_client.h"

#include "phxrpc/file.h"

#include "minichat_api.h"

using namespace phxrpc;

LogicToolImpl:: LogicToolImpl()
{
}

LogicToolImpl:: ~LogicToolImpl()
{
}

int LogicToolImpl :: PHXEcho( phxrpc::OptMap & opt_map )
{
    google::protobuf::StringValue req;
    google::protobuf::StringValue resp;

    if( NULL == opt_map.Get( 's' ) ) return -1;

    req.set_value( opt_map.Get( 's' ) );

    LogicClient client;
    int ret = client.PHXEcho( req, &resp );
    printf( "%s return %d\n", __func__, ret );
    printf( "resp: {\n%s}\n", resp.DebugString().c_str() );

    return ret;
}

int LogicToolImpl :: Auth( phxrpc::OptMap & opt_map )
{
    if( NULL == opt_map.Get( 'u' ) || NULL == opt_map.Get( 'p' ) ) {
        return -1;
    }

    MiniChatAPI api;

    logic::AuthResponse resp_obj, auth_resp_obj;

    int ret = api.Auth( opt_map.Get( 'u' ), opt_map.Get( 'p' ), &resp_obj );

    printf( "%s return %d\n", __func__, ret );
    printf( "resp: {\n%s}\n", resp_obj.DebugString().c_str() );

    ret = api.AutoAuth( &auth_resp_obj );

    printf( "AutoAuth return %d\n", ret );
    printf( "resp: {\n%s}\n", auth_resp_obj.DebugString().c_str() );

    return ret;
}

static void PrintSyncResp( logic::SyncResponse & resp )
{
    printf( "optlog %d\n", resp.oplog_size() );

    for( int i = 0; i < resp.oplog_size(); i++ ) {
        const logic::CmdItem & item = resp.oplog( i );

        if( item.type() == logic::CMD_ADD_MSG ) {
            logic::CmdAddMsg cmd;
            cmd.ParseFromString( item.buff() );

            printf( "#%d\n%s\n", i, cmd.DebugString().c_str() );
        }

        if( item.type() == logic::CMD_MOD_CONTACT ) {
            logic::CmdModContact cmd;
            cmd.ParseFromString( item.buff() );

            printf( "#%d\n%s\n", i, cmd.DebugString().c_str() );
        }
    }
}

int LogicToolImpl :: Sync( phxrpc::OptMap & opt_map )
{
    if( NULL == opt_map.Get( 'u' ) ) return -1;

    MiniChatAPI api;

    logic::SyncResponse resp_obj;

    api.SetUsername( opt_map.Get( 'u' ) );

    if( opt_map.Has( 'm' ) ) api.GetSyncKey()->set_msg_seq( atoi( opt_map.Get( 'm' ) ) );
    if( opt_map.Has( 'c' ) ) api.GetSyncKey()->set_contact_seq( atoi( opt_map.Get( 'c' ) ) );

    int ret = api.Sync( &resp_obj );
    
    printf( "%s return %d\n", __func__, ret );
    printf( "resp_obj: {\n%s}\n", resp_obj.DebugString().c_str() );

    PrintSyncResp( resp_obj );

    printf( "Contacts:\n" );
    for( auto & c : api.GetContacts() ) {
        printf( "%s\n", c.c_str() );
    }

    return ret;
}

int LogicToolImpl :: SendMsg( phxrpc::OptMap & opt_map )
{
    if( NULL == opt_map.Get( 's' ) || NULL == opt_map.Get( 't' )
            || NULL == opt_map.Get( 'm' ) ) {
        return -1;
    }

    MiniChatAPI api;

    logic::SendMsgResponse resp_obj;

    api.SetUsername( opt_map.Get( 's' ) );

    int ret = api.SendMsg( opt_map.Get( 't' ), opt_map.Get( 'm' ), &resp_obj );

    printf( "%s return %d\n", __func__, ret );
    printf( "resp_obj: {\n%s\n}\n", resp_obj.DebugString().c_str() );

    return ret;
}

int LogicToolImpl :: FakeDoAll( phxrpc::OptMap & opt_map )
{
    int ret = -1;

    if( NULL == opt_map.Get( 'u' ) || NULL == opt_map.Get( 'p' ) ) {
        return -1;
    }

    const char * username = opt_map.Get( 'u' );
    const char * pwd_md5 = opt_map.Get( 'p' );

    phxrpc::UThreadEpollScheduler scheduler( 64 * 1024, 10 );

    for( int i = 0; i < 1; i++ ) {
        phxrpc::__uthread( scheduler ) - [=,&scheduler,&ret]( void * ) {

            MiniChatAPI api( &scheduler );

            logic::AuthResponse auth_resp;
            ret = api.Auth( username, pwd_md5, &auth_resp );
            printf( "Auth %d\n", ret );
            printf( "resp: {\n%s}\n", auth_resp.DebugString().c_str() );

            logic::SendMsgResponse sendmsg_resp;
            ret = api.SendMsg( username, "hello", &sendmsg_resp );
            printf( "SendMsg %d\n", ret );
            printf( "resp: {\n%s}\n", sendmsg_resp.DebugString().c_str() );

            logic::SyncResponse sync_resp;
            ret = api.Sync( &sync_resp );
            printf( "Sync %d\n", ret );
            printf( "resp: {\n%s}\n", sync_resp.DebugString().c_str() );

            PrintSyncResp( sync_resp );
        };
    }

    scheduler.Run();

    return ret;
}

